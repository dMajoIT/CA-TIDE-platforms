include "global.tbh"

'http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.html
'https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/

const MQTT_INIT_SIGNATURE=&h1688
const MQTT_STAMP="MQTT> "
const MQTT_CR_LF=chr(13)+chr(10)
const MQTT_TIMEOUT=2000

'Message Types
const CONNECT		=&h10
const CONNACK		=&h20
const PUBLISH		=&h30
const PUBACK		=&h40
const PUBREC 		=&h50
const PUBREL		=&h60
const PUBCOMP 		=&h70
const SUBSCRIBE		=&h80
const SUBACK		=&h90
const UNSUBSCRIBE 	=&hA0
const UNSUBACK 		=&hB0
const PINGREQ 		=&hC0
const PINGRESP 		=&hD0
const DISCONNECT 	=&hE0

'mqtt protocol string
const MQTT_LEVEL	=&h04
const MQTT_PROTOCOL	="MQTT"

enum en_mqtt_states
	
	EN_MQTT_STATES_IDLE,
	EN_MQTT_STATES_NOT_CONNECTED,
	EN_MQTT_STATES_DNS_NOT_COMPLETE,
	EN_MQTT_STATES_CONNECTING,
	EN_MQTT_STATES_CONNECTED,
	EN_MQTT_STATES_LOGGED_IN
	
end enum

dim mqtt_init_flag as word
dim mqtt_packet_identifier as word
dim mqtt_sock_num as byte
dim mqtt_state as en_mqtt_states
dim mqtt_connection_counter as word
dim mqtt_ping_counter as word
dim mqtt_server_port as word
dim mqtt_server_address as string
dim mqtt_server_ip as string(15)
dim mqtt_user as string(30)
dim mqtt_pw	as string(23)
dim mqtt_packet_length as long
dim mqtt_client_id as string=""
dim mqtt_target_interface as pl_sock_interfaces
dim mqtt_encrypted as boolean

#if MQTT_DEBUG_PRINT=1
	declare sub mqtt_debug_print(data as string)
#endif

'-------------------------------------------------------------
sub mqtt_start(target_interface as pl_sock_interfaces, byref server as string, dst_port as word, byref user as string, byref password as string, byref client_id as string, encrypted as boolean)
'API procedure, starts the MQTT library.
'MUST be called first, before any other procedure in this library is used.
	
	if mqtt_init_flag=MQTT_INIT_SIGNATURE then
		#if MQTT_DEBUG_PRINT=1
			mqtt_debug_print("MQTT library already initialized.")
		#endif
		exit sub
	end if

	#if MQTT_DEBUG_PRINT=1
		mqtt_debug_print("---START---")
	#endif
	mqtt_init_flag=MQTT_INIT_SIGNATURE
	mqtt_state=EN_MQTT_STATES_NOT_CONNECTED
	mqtt_packet_identifier=0
	mqtt_sock_num=sock_get("MQTT")
    mqtt_target_interface=target_interface
	mqtt_server_port=dst_port
	mqtt_server_address=server
    mqtt_user=user
    mqtt_pw=password
	mqtt_encrypted=encrypted
    if client_id<>"" then mqtt_client_id=client_id
	sock.num=mqtt_sock_num
	sock.targetinterface=target_interface
	sock.targetport=dst_port
	sock.protocol=PL_SOCK_PROTOCOL_TCP
	sock.inconmode = PL_SOCK_INCONMODE_ANY_IP_ANY_PORT
	sock.gendataarrivalevent=YES
	sock.reconmode=PL_SOCK_RECONMODE_3
	sock.connectiontout=0
	if sys.freebuffpages<MQTT_RX_BUFF+MQTT_TX_BUFF then
		#if MQTT_DEBUG_PRINT=1
			mqtt_debug_print("Insufficient buffer memory.")
		#endif
		exit sub
	end if
	sock.rxbuffrq(MQTT_RX_BUFF)
	sock.txbuffrq(MQTT_TX_BUFF)
	sys.buffalloc()
	mqtt_connect()
	
end sub


function mqtt_build_remaining_length(size as dword) as string(2)
	mqtt_build_remaining_length = ""
	do
		dim encodedByte as byte = size mod 128
		size = size / 128
		if (size > 0) then encodedByte = encodedByte or 128
		mqtt_build_remaining_length = mqtt_build_remaining_length + chr(encodedByte)
	loop while (size > 0)
end function

function mqtt_get_packet_identifier() as string(2)
	mqtt_packet_identifier = (mqtt_packet_identifier mod 65535) + 1
	mqtt_get_packet_identifier = chr(mqtt_packet_identifier/256)+chr(mqtt_packet_identifier mod 256)
end function

sub mqtt_sock_setdata(byref txdata as string)
if mqtt_encrypted then
	sock.tlssetdata(txdata)
else
	sock.setdata(txdata)
end if
end sub

function mqtt_sock_getdata(byref maxinplen as word) as string
#if SUPPORTS_TLS
	mqtt_sock_getdata=sock.tlsgetdata(maxinplen)
#else
	mqtt_sock_getdata=sock.getdata(maxinplen)
#endif
end function

function mqtt_sock_peekdata (byref maxinplen as word) as string
#if SUPPORTS_TLS
	mqtt_sock_peekdata =sock.tlspeekdata(maxinplen)
	if 0 then
		mqtt_sock_peekdata = sock.tlsgetdata(maxinplen)
		sys.debugprint(mqtt_sock_peekdata)
	end if
#else
	mqtt_sock_peekdata  =sock.peekdata(maxinplen)
#endif
end function

sub mqtt_send_login()
	dim buf as string
	dim client_id, user_id, password as string	
	dim size as dword=0
	if mqtt_user = "" then
		buf=chr(&h0)+chr(len(MQTT_PROTOCOL))+MQTT_PROTOCOL+chr(MQTT_LEVEL)+chr(&h02)+chr(0)+chr(&h3c)+chr(0)+chr(len(mqtt_client_id))+mqtt_client_id
		buf=chr(CONNECT)+mqtt_build_remaining_length(len(buf)) + buf
		mqtt_sock_setdata(buf)		
	else
		buf=chr(&h0)+chr(len(MQTT_PROTOCOL))+MQTT_PROTOCOL+chr(MQTT_LEVEL)+chr(&hc2)+chr(0)+chr(&h3c)
		size=size+len(buf)
		client_id=chr(0)+chr(len(mqtt_client_id))+mqtt_client_id 
		size=size+len(client_id)
		user_id=chr(0)+chr(len(mqtt_user)) + mqtt_user 
		size=size+len(user_id)
		password=chr(0)+chr(len(mqtt_pw)) + mqtt_pw
		size=size+len(password)
		mqtt_sock_setdata(chr(CONNECT)+mqtt_build_remaining_length(size))
		mqtt_sock_setdata(buf)
		mqtt_sock_setdata(client_id)
		mqtt_sock_setdata(user_id)
		mqtt_sock_setdata(password)
	end if
	sock.send()
end sub

sub mqtt_connect_socket()
	sock.num=mqtt_sock_num
	sock.targetip=mqtt_server_ip
	if mqtt_encrypted=true then
	#if SUPPORTS_TLS
		sock.tlsdeinit()
		#if PLATFORM_ID <> WM2000
			sock.tlsbuffrq(39)	
			sys.buffalloc()
		#endif
		#ifdef MQTT_CER_FILE
			romfile.open(MQTT_CER_FILE)
			dim tlsinit as pl_tls_result=sock.tlsinit(romfile.offset)  'check return state
		#else
			sock.tlsinit(0)
		#endif
		sock.rxclear()
		sock.txclear()
		#endif
	end if
	sock.connect()
	mqtt_state=EN_MQTT_STATES_CONNECTING
	mqtt_connection_counter=MQTT_CONNECTION_TIMER*2
end sub

function mqtt_connect() as ok_ng
'API function, instructs the library to connect to the MQTT server (broker).<br><br>
'<b>dst_ip</b>- the IP address of the MQTT server,<br>
'<b>dst_port</b>- target port on the MATT server,<br>
'<b>user</b> and <b>password</b>- MQTT server login credentials,<br>
'<b>url</b> is used for ssl certerficate validation<br>
'<b>client_id</b> unique client ID string for your app must be defined to use MQTT<br>
'<b>keep_alive</b>- the interval, in seconds, at which the server will ping this device.<br><br>
'Returns OK if executed successfully.
	mqtt_connect = NG
	if mqtt_init_flag<>MQTT_INIT_SIGNATURE then
		#if MQTT_DEBUG_PRINT=1
			mqtt_debug_print("ERROR: mqtt_start() wasn't called.")
		#endif
		exit function
	end if
	
	sock.num=mqtt_sock_num	
	dim is_ip_address as boolean=true
	dim b as byte
	for b=1 to len(mqtt_server_address)
        dim s as string=mid(mqtt_server_address,b,1)
        dim ascii as word=asc(s)
        if ascii>=46 and ascii<=57 then
        else
            is_ip_address=false
            exit for
        end if
    next b

    if is_ip_address = false then
        if dns_connect(mqtt_target_interface,"",0) = EN_STATUS_DNS_OK then
            dns_query(mqtt_server_address)	
		end if
	else
		mqtt_server_ip=mqtt_server_address
		mqtt_connect_socket()
	end if	
	
end function

sub mqtt_disconnect()
'API procedure, disconnects the device from the MQTT server (broker).	
	
	if mqtt_init_flag<>MQTT_INIT_SIGNATURE then
		#if MQTT_DEBUG_PRINT=1
			mqtt_debug_print("ERROR: mqtt_start() wasn't called.")
		#endif
		exit sub
	end if
	
	dim current_sock as byte = sock.num
	dim buf as string = chr(DISCONNECT)+chr(0)
	mqtt_state=EN_MQTT_STATES_IDLE
	sock.num = mqtt_sock_num
	mqtt_sock_setdata(buf)
	sock.send
	sock.num = current_sock
	
end sub

sub mqtt_publish(byref topic as string, byref data as string, qos as en_qos_choices)
'API procedure, publishes a <b>topic</b> and its <b>data</b> to the MQTT server (broker).
	
	if mqtt_init_flag<>MQTT_INIT_SIGNATURE then
		#if MQTT_DEBUG_PRINT=1
			mqtt_debug_print("ERROR: mqtt_start() wasn't called.")
		#endif
		exit sub
	end if
	if mqtt_state<>EN_MQTT_STATES_LOGGED_IN then exit sub

	dim buf as string
	dim remaining_length as byte
	dim current_sock as byte = sock.num

	#if MQTT_DEBUG_PRINT=1
		mqtt_debug_print("Publishing: topic="+topic+", data="+data)
	#endif

	if (qos = QOS_AT_MOST_ONCE) then
		buf=chr(0)+chr(len(topic))+topic+data
	else
		buf=chr(0)+chr(len(topic))+topic+mqtt_get_packet_identifier()+data
	end if
	
	buf=chr(PUBLISH+1+(qos*2))+mqtt_build_remaining_length(len(buf)) + buf

	sock.num=mqtt_sock_num
	mqtt_sock_setdata(buf)
	sock.send
	mqtt_ping_counter=MQTT_PING_TIMER*2
	sock.num = current_sock
end sub

sub mqtt_sub(byref topic as string,qos as en_qos_choices)
'API procedure, subscribes the device to the specified topic on the MQTT server (broker).<br><br>
'<b>topic</b>- the topic to subscribe to,<br>
'<b>qos</b>- requested quality of service, according to the en_qos_choices enum.
	
	if mqtt_init_flag<>MQTT_INIT_SIGNATURE then
		#if MQTT_DEBUG_PRINT=1
			mqtt_debug_print("ERROR: mqtt_start() wasn't called.")
		#endif
		exit sub
	end if
	if mqtt_state<>EN_MQTT_STATES_LOGGED_IN then exit sub

	dim buf as string
	dim current_sock as byte = sock.num
	
	#if MQTT_DEBUG_PRINT=1
		mqtt_debug_print("Subscribing to: data="+topic)
	#endif
	
	buf=mqtt_get_packet_identifier()+chr(0)+chr(len(topic))+topic+chr(qos)
	buf=chr(SUBSCRIBE+2)+mqtt_build_remaining_length(len(buf)) + buf

	sock.num=mqtt_sock_num
	mqtt_sock_setdata(buf)
	sock.send
	
	sock.num = current_sock
end sub

sub mqtt_unsub(byref topic as string)
'API procedure, unsubscribes the device from the specified topic.<br><br>
'<b>topic</b>- message to unsubscribe from.
	
	if mqtt_init_flag<>MQTT_INIT_SIGNATURE then
		#if MQTT_DEBUG_PRINT=1
			mqtt_debug_print("ERROR: mqtt_start() wasn't called.")
		#endif
		exit sub
	end if
	if mqtt_state<>EN_MQTT_STATES_LOGGED_IN then exit sub

	dim buf as string
	dim current_sock as byte = sock.num
	
	#if MQTT_DEBUG_PRINT=1
		mqtt_debug_print("Unsubscribing from: data="+topic)
	#endif
	
	buf=mqtt_get_packet_identifier()+chr(0)+chr(len(topic))+topic
	buf=chr(UNSUBSCRIBE+2)+mqtt_build_remaining_length(len(buf)) + buf
	
	sock.num=mqtt_sock_num
	mqtt_sock_setdata(buf)
	sock.send
	
	sock.num = current_sock
	
end sub

sub mqtt_ping()
	
	sock.num=mqtt_sock_num
	mqtt_ping_counter=mqtt_ping_counter-1
	if mqtt_ping_counter=0 then
		if sock.rxlen=0 then
			#if MQTT_DEBUG_PRINT=1
				mqtt_debug_print("Ping.")
			#endif
			mqtt_sock_setdata(chr(PINGREQ)+chr(0))
			sock.send()
			mqtt_ping_counter=MQTT_PING_TIMER*2
		end if
	end if

end sub

sub mqtt_proc_timer()
'Event procedure, call it from the on_sys_timer() event handler.

	if mqtt_init_flag<>MQTT_INIT_SIGNATURE then exit sub
	
	if mqtt_state=EN_MQTT_STATES_LOGGED_IN then 
		mqtt_ping()
	else
		mqtt_connection_counter=mqtt_connection_counter-1
		if mqtt_connection_counter=0 then
			select case mqtt_state
			case EN_MQTT_STATES_NOT_CONNECTED:
				mqtt_connect()
				#if MQTT_DEBUG_PRINT=1
					mqtt_debug_print("Retrying connection...")
				#endif
			case EN_MQTT_STATES_CONNECTING:
				mqtt_connect()
				#if MQTT_DEBUG_PRINT=1
					mqtt_debug_print("Connection timed out. Reconnecting...")
				#endif
			case EN_MQTT_STATES_CONNECTED:
				mqtt_state=EN_MQTT_STATES_NOT_CONNECTED
				mqtt_connection_counter=MQTT_RECONNECT_TIME*2
				#if MQTT_DEBUG_PRINT=1
					mqtt_debug_print("Unable to log in to server...")
				#endif		
			end select
		end if
	end if
			
end sub


sub mqtt_sock_event(newstate as enum pl_sock_state, newstatesimple as enum pl_sock_state_simple)
	
	if sock.num<>mqtt_sock_num then 
		exit sub 
	end if
	
	select case newstate
	case PL_SST_CLOSED, PL_SST_CL_PCLOSED:
		if mqtt_state<>EN_MQTT_STATES_IDLE then
			mqtt_state=EN_MQTT_STATES_NOT_CONNECTED
			mqtt_connection_counter=MQTT_RECONNECT_TIME*2
			#if MQTT_DEBUG_PRINT=1
			mqtt_debug_print("Lost server connection.")
			#endif
		end if
	case PL_SST_EST_AOPENED:
		if mqtt_encrypted=false then
			mqtt_send_login()
			mqtt_state=EN_MQTT_STATES_CONNECTED
		else
			if mqtt_server_address<>mqtt_server_ip then
				dim hsres as pl_tls_result = sock.tlshandshake(mqtt_server_address)
				sys.debugprint(str(hsres))
			else
				sock.tlshandshake("")
			end if
			mqtt_connection_counter=MQTT_CONNECTION_TIMER*2
		end if
	case PL_SST_TLS_EST:
		mqtt_send_login()
		mqtt_state=EN_MQTT_STATES_CONNECTED
	end select
	
end sub


sub mqtt_proc_data()
'Event procedure, call it from the on_sock_data_arrival event handler.
	
	if mqtt_init_flag<>MQTT_INIT_SIGNATURE then exit sub
	if sock.num<>mqtt_sock_num then exit sub

	dim pos as byte = 2
	dim buf as string
	if mqtt_encrypted then
		buf = sock.tlspeekdata(2)
	else
		buf = sock.peekdata(2)
	end if
	
	
	if (len(buf) < 2) then
		exit sub
	end if

	'total sequence length
	dim length as word = asc(right(buf,1))
	if (length > 127) then pos = pos + 1
	dim rxbufflen as dword
	if mqtt_encrypted then
		rxbufflen=sock.tlspeeklen
	else 
		rxbufflen=sock.rxlen
	end if
	if (length + pos <= rxbufflen) then
		if mqtt_encrypted then
			buf = sock.tlsgetdata(length + pos)
		else
			buf = sock.getdata(length + pos)		
		end if
	else
		exit sub	
	end if

	dim head as byte = asc(left(buf,1))
	dim qos as en_qos_choices = (head and &h06) shr 1
	head = (head and &hF0)
	
	buf = right(buf,length)

	select case (head)
		
		case CONNACK:	#if MQTT_DEBUG_PRINT=1		
							mqtt_debug_print("Connected to server.")
						#endif
						mqtt_ping_counter=MQTT_PING_TIMER*2
						mqtt_state=EN_MQTT_STATES_LOGGED_IN
						mqtt_connection_counter=MQTT_CONNECTION_TIMER*2
						callback_mqtt_connect_ok()
		
		case PUBLISH:	length=asc(mid(buf,1,1))*256 +asc(mid(buf,2,1))
						#if MQTT_DEBUG_PRINT=1
							mqtt_debug_print("Notification: topic="+mid(buf,3,length)+", data="+right(buf,len(buf)-length-2-((qos<>QOS_AT_MOST_ONCE)*2)))
						#endif
						callback_mqtt_notif(mid(buf,3,length),right(buf,len(buf)-length-2-((qos<>QOS_AT_MOST_ONCE)*2)))
						if (qos = QOS_AT_LEAST_ONCE) then
							buf = chr(PUBACK) + chr(2) + mid(buf,length+3,2)
							mqtt_sock_setdata(buf)
							sock.send
						else if (qos = QOS_EXACTLY_ONCE) then
							buf = chr(PUBREC) + chr(2) + mid(buf,length+3,2)
							mqtt_sock_setdata(buf)
							sock.send
						end if
		
		case PUBACK:	#if MQTT_DEBUG_PRINT=1
							mqtt_debug_print("Publish ack.")
						#endif
		
		case PUBREC:	#if MQTT_DEBUG_PRINT=1
							mqtt_debug_print("Publish rec.")
						#endif
						buf=chr(PUBREL+2) + chr(2) + buf
						mqtt_sock_setdata(buf)
						sock.send
		
		case PUBREL:	#if MQTT_DEBUG_PRINT=1
							mqtt_debug_print("Publish rel.")
						#endif
						buf=chr(PUBCOMP) + chr(2) + buf
						mqtt_sock_setdata(buf)
						sock.send						
		
		case PUBCOMP:	#if MQTT_DEBUG_PRINT=1
							mqtt_debug_print("Publish comp.")
						#endif
		
		case SUBACK:	#if MQTT_DEBUG_PRINT=1
							mqtt_debug_print("Subscribe ack.")
						#endif
						callback_mqtt_sub_ok()
		
		case UNSUBACK:	#if MQTT_DEBUG_PRINT=1
							mqtt_debug_print("Unsubscribe ack.")
						#endif
		
		case PINGRESP:	#if MQTT_DEBUG_PRINT=1
							mqtt_debug_print("Ping response.")
						#endif
	end select

end sub

sub mqtt_dns_answer_acquired(return_type as en_dns_return_type, byref return_string as string)
	
	if(return_type=EN_DNS_RET_IP) then
        if dns_current_domain() = mqtt_server_address then
            mqtt_server_ip = ddstr(return_string) 
			mqtt_connect_socket()
        end if
	end if
	
end sub

#if MQTT_DEBUG_PRINT=1
sub mqtt_debug_print(data as string)
	sys.debugprint(MQTT_STAMP+data+MQTT_CR_LF)
end sub
#endif

#if MQTT_LARGE_PACKETS
	
	sub mqtt_start_publish(byref topic as string, qos as en_qos_choices, length as dword)
	'API procedure, starts the procedure of publishing to the MQTT server (broker). Must be called before calling mqtt_continue_publish().
	'<b>topic</b> - Name of the topic to be published
	'<b>qos</b> - QoS level
	'<b>length</b> - Total length of the payload to be sent


		if mqtt_init_flag<>MQTT_INIT_SIGNATURE then
			#if MQTT_DEBUG_PRINT=1
				mqtt_debug_print("ERROR: mqtt_start() wasn't called.")
			#endif
			exit sub
		end if
		if mqtt_cur_state<>ms_connected then exit sub
			
		if mqtt_packet_length<>0 then
			#if MQTT_DEBUG_PRINT=1
			mqtt_debug_print("ERROR: Previous MQTT packet not fully sent. " + str(mqtt_packet_length) + " bytes remaining.")
			#endif
			mqtt_packet_length=0
			exit sub
		end if
		mqtt_packet_length=length
		dim buf as string
		dim remaining_length as byte
		dim current_sock as byte = sock.num
		dim tmr as dword
		#if MQTT_DEBUG_PRINT=1
			mqtt_debug_print("Publishing: topic="+topic)
		#endif

		if (qos = QOS_AT_MOST_ONCE) then
			buf=chr(0)+chr(len(topic))+topic
		else
			buf=chr(0)+chr(len(topic))+topic+mqtt_get_packet_identifier()
		end if
		
		buf=chr(PUBLISH+1+(qos*2))+mqtt_build_remaining_length(len(buf) + length) + buf

		sock.num=mqtt_sock_num
		
		dim buf_len as byte=len(buf)
		tmr=sys.timercountms
		while buf_len>0 and sys.timercountms-tmr<MQTT_TIMEOUT
			dim tx_free as word = sock.txfree/2
			if buf_len<=tx_free then
				mqtt_sock_setdata(buf)
				buf_len=0
			else
				mqtt_sock_setdata(left(buf,tx_free))
				buf=right(buf,len(buf)-tx_free)
				buf_len=buf_len-tx_free
			end if		
			sock.send
			mqtt_timer_record=0
			tmr=sys.timercountms
		wend
		
		sock.num = current_sock

	end sub

	sub mqtt_continue_publish(byref data as string)
	'API procedure, continues publishing to the MQTT server (broker). Must be called until the number of bytes set in mqtt_start_publish() has been reached.
	'<b>data</b> - Data to be sent. Cannot exceed 255 bytes. To send a payload greater than 255 bytes, the subroutine must be called again.

		dim tmr as dword

		if mqtt_init_flag<>MQTT_INIT_SIGNATURE then
			#if MQTT_DEBUG_PRINT=1
				mqtt_debug_print("ERROR: mqtt_start() wasn't called.")
			#endif
			exit sub
		end if
		if mqtt_cur_state<>ms_connected then exit sub

		mqtt_packet_length=mqtt_packet_length-len(data)
		if mqtt_packet_length < 0 then
			#if MQTT_DEBUG_PRINT=1
				mqtt_debug_print("ERROR: Number of bytes being sent exceeds number set in header")
			#endif
			mqtt_packet_length=0
			exit sub
		end if
		
		dim current_sock as byte = sock.num
		sock.num=mqtt_sock_num
		
		dim length as byte=len(data)
		tmr=sys.timercountms
		while length>0 and sys.timercountms-tmr<MQTT_TIMEOUT
			dim tx_free as word = sock.txfree/2
			 
			if length<=tx_free then
				mqtt_sock_setdata(data)
				length=0
			else
				mqtt_sock_setdata(left(data,tx_free))
				data=right(data,len(data)-tx_free)
				length=length-tx_free
			end if		
			sock.send
			mqtt_timer_record=0
			tmr=sys.timercountms
		wend
		
		sock.num = current_sock

	end sub

#endif
 