
'**************************************************************************************************
'       SYS (System) object
'**************************************************************************************************

object sys
'This is the system object that loosely combines "general system" stuff such as initialization (boot) event, buffer
'management, system timer, and some other miscellaneous properties and methods.


'--------------------------------------------------------------------
syscall(82,"32.TDL") sys.buffalloc()
'<b>METHOD. </b><br><br>
'Allocates buffer memory as previously requested by "buffrq" methods of individual objects (such as <font color="maroon"><b>
'ser.rxbuffrq</b></font>).<br><br>
'This method takes significant amount of time (100s of milliseconds) to execute, during which time the device cannot receive network packets,
'serial data, etc. For certain interfaces like serial ports some incoming data could be lost. <br><br>
'Buffer (re)allocation for a specific object will only work if the corresponding object or part of the object to which this buffer belongs is 
'idle. "Part" refers to a particular serial port of the ser object, or particular socket of the sock object, etc. to which the buffer you are
'trying to change belongs. <br><br>
'"Idle" means different things for different objects: <font color="maroon"><b>ser.enabled</b></font>= <font color="olive"><b>0- NO </b></font> 
'for the serial port, <font color="maroon"><b> sock.statesimple</b></font>=  <font color="olive"><b>0- PL_SSTS_CLOSED </b></font> for the 
'socket, etc.


'--------------------------------------------------------------------
syscall(543,"74.TDL") sys.debugprint(byref str as string)
'<b>METHOD.</b><br><br>
'Sends (prints) a string to the TIDE's console output.<br><br>
'The method allows you to trace the execution of your debug application by printing messages in the console output pane of TIDE. 
'This method only works when the <font color="maroon"><b>sys.runmode</b></font> = <font color="olive"><b>1 - PL_SYS_MODE_DEBUG</b></font>.
'<br><br>On platform with wireless debugging, you also need to take into account performance degradation due to UDP communications over Wi-Fi. 
'If you have a significant amount of debug messages, TIDE must wait for replies from your device for each one, which can lead to slow performance.

#if BUFF_PAGE_TYPE=byte

    '--------------------------------------------------------------------
    property sys.freebuffpages
    '<b>R/O PROPERTY (BYTE). </b><br><br>
    'Returns the number of free (not yet allocated) buffer pages (one page= 256 bytes). Only changes after the <font color="maroon"><b>
    'sys.buffalloc </b></font> method is used. Preparatory methods like <font color="maroon"><b>ser.rxbuffrq </b></font>do not influence what 
    'this property returns. <br><br>
    'See also <font color="maroon"><b>sys.totalbuffpages</b></font>.
        get = syscall(84,"33.TDL"+) as byte
    end property

#elif BUFF_PAGE_TYPE=word

    '--------------------------------------------------------------------
    property sys.freebuffpages
    '<b>R/O PROPERTY (WORD). </b><br><br>
    'Returns the number of free (not yet allocated) buffer pages (one page= 256 bytes). Only changes after the <font color="maroon"><b>
    'sys.buffalloc </b></font> method is used. Preparatory methods like <font color="maroon"><b>ser.rxbuffrq </b></font>do not influence what 
    'this property returns. <br><br>
    'See also <font color="maroon"><b>sys.totalbuffpages</b></font>.
        get = syscall(84,"33.TDL"+) as word
    end property

#endif 

'--------------------------------------------------------------------
syscall(69) sys.halt()
'<b>METHOD. </b><br><br>
'Stops your program execution (halts VM). In the debug mode (<font color="maroon"><b>sys.runmode</b></font>= <font color="olive"><b>
'1- PL_SYS_MODE_DEBUG</b></font>) causes the same result as when you press PAUSE in TIDE during the debug session. <br><br>
'In the release mode (<font color="maroon"><b>sys.runmode</b></font>= <font color="olive"><b>0- PL_SYS_MODE_RELEASE</b></font>) causes the 
'device to halt (stop) execution. <br><br>
'Once this method has been used, there is no way for your device to resume execution on its own. <br><br>
'See also <font color="maroon"><b>sys.reboot</b></font>.

'--------------------------------------------------------------------
property !sys.limitbuffersize
    get = syscall(644) as no_yes
    set= syscall(645) (value as no_yes)
end property

'--------------------------------------------------------------------
property sys.onsystimerperiod
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 50 (0.5 seconds). </b><br><br>
'Defines, in 10ms increments, the period at which the <font color="teal"><b>on_sys_timer </b></font> event will be generated.
    get = syscall(292) as byte
    set = syscall(293) (value as byte)
end property

'--------------------------------------------------------------------
enum pl_sys_reset_type
    PL_SYS_RESET_TYPE_INTERNAL, '<b>PLATFORM CONSTANT. </b><br><br> The most recent reset was generated internally.
    PL_SYS_RESET_TYPE_EXTERNAL  '<b>PLATFORM CONSTANT. </b><br><br> The most recent reset was generated externally (e.g. through RST pin
                                'or power cycle).
end enum

'--------------------------------------------------------------------
enum pl_sys_mode
    PL_SYS_MODE_RELEASE,    '<b>PLATFORM CONSTANT. </b><br><br> 
                            'Debugging is not possible, application execution starts immediately after device powers up. Severe errors
                            'such as "divizion by zero" are ignored and do not stop execution.
    PL_SYS_MODE_DEBUG       '<b>PLATFORM CONSTANT. </b><br><br> 
                            'Debug mode in which it is possible to cross-debug the application (under the control of TIDE software). 
                            'Application execution is not started automatically after the power up. Severe errors such as "divizion by 
                            'zero" halt execution.
end enum

'--------------------------------------------------------------------
syscall(70) sys.reboot()
'<b>METHOD. </b><br><br> 
'Causes your device to reboot through internal reset. After the device reboots it will behave as after any other reboot: enter PAUSE 
'mode if your program was compiled for debugging, or start execution if the program was compiled for release. <br><br>
'See also <font color="maroon"><b>sys.runmode</b></font>, <font color="maroon"><b>sys.resettype</b></font>, and
'<font color="maroon"><b>sys.halt</b></font>.

'--------------------------------------------------------------------
property sys.resettype
'<b>R/O PROPERTY (ENUM, BYTE). </b><br><br>
'Returns the type of the most recent hardware reset:<br><br><font color="olive"><b>0- PL_SYS_RESET_TYPE_INTERNAL </b></font>(internal 
'reset caused  by "self-reboot" of the CPU -- through TIDE command or <font color="maroon"><b>sys.reboot </b></font> execution),<br><font 
'color="olive"><b>1- PL_SYS_RESET_TYPE_EXTERNAL </b></font> (caused by power-cycling of the device or applying reset pulse to the RST line).
    get = syscall(72) as pl_sys_reset_type
end property

'--------------------------------------------------------------------
property sys.runmode
'<b>R/O PROPERTY (ENUM, BYTE). </b><br><br>
'Returns current run (execution) mode: <br><br>
'<font color="olive"><b>0- PL_SYS_MODE_RELEASE </b></font>(release mode),<br> <font color="olive"><b>1- PL_SYS_MODE_DEBUG </b></font> 
'(debug mode).
    get = syscall(71) as pl_sys_mode
end property

'--------------------------------------------------------------------
property sys.timercount
'<b>R/O PROPERTY (WORD). </b><br><br>
'Returns the time (in half-second intervals) elapsed since the device powered up. Once the value of this timer reaches 65535, it rolls over to 0.<br><br>
'See also <font color="teal"><b>on_sys_timer </b></font> event.
    get = syscall(136) as word
end property

#if BUFF_PAGE_TYPE=byte
'--------------------------------------------------------------------
property sys.totalbuffpages
'<b>R/O PROPERTY (BYTE). </b><br><br>
'Returns the total amount of memory pages available for buffers (one page= 256 bytes). This is calculated as total available variable memory
'(RAM) minus whatever is required to store variables of the current project. <br><br>
'See also <font color="maroon"><b>sys.buffalloc </b></font> and <font color="maroon"><b>sys.freebuffpages</b></font>.
    get = syscall(83,"33.TDL"+) as byte
end property

#elif BUFF_PAGE_TYPE=word

'--------------------------------------------------------------------
property sys.totalbuffpages
'<b>R/O PROPERTY (WORD). </b><br><br>
'Returns the total amount of memory pages available for buffers (one page= 256 bytes). This is calculated as total available variable memory
'(RAM) minus whatever is required to store variables of the current project. <br><br>
'See also <font color="maroon"><b>sys.buffalloc </b></font> and <font color="maroon"><b>sys.freebuffpages</b></font>.
    get = syscall(83,"33.TDL"+) as word
end property

#endif 

'--------------------------------------------------------------------
property sys.version
'<b>R/O PROPERTY (STRING). </b><br><br>
'Returns firmware (TiOS) version string. Example: "EM1000-1.20.00".
    get = syscall(428,"74.TDL"+) as string
end property

'**************************************************************************************************
'       SYS (System) object events
'**************************************************************************************************

'--------------------------------------------------------------------
event(1)  on_sys_init
'<b>EVENT of the sys object. </b><br><br> First event to be generated after your devices boots up. Typically, initialization code for
'your application is placed here.

'--------------------------------------------------------------------
event(2)  on_sys_timer
'<b>EVENT of the sys object. </b><br><br> Periodic event that is generated at intervals defined by the <font color="maroon"><b>sys.onsystimerperiod </b></font>property.
'<br><br>
'Multiple <font color="teal"><b>on_sys_timer </b></font> 
'events may be waiting in the event queue. Using doevents statement in the event handler for this event or the body of any procedure in the related
'call chain may lead to the skipping (loss) of identical events waiting in the queue. This will happen when the 
'<font color="teal"><b>on_sys_timer </b></font>
'event is taken off the queue in the cause of the doevents execution related to the same event taken off the queue earlier.
'This is usually not a problem since this event is generated periodically anyway.
'<br><br>
'The <font color="teal"><b>on_sys_timer </b></font>
'event is not generated when the program execution is PAUSED (in debug mode).


#if SYS_VER_SUPPORTS_PROFILE = 1

    '--------------------------------------------------------------------
    syscall(576,"101.TDL") !sys.profile() as string

    '--------------------------------------------------------------------
    syscall(95) !sys.nosw() as string

    '--------------------------------------------------------------------
    syscall(19) !sys.sw() as string

#endif 


#if SYS_VER_SUPPORTS_MS=1

    '--------------------------------------------------------------------
    property sys.timercountms
    '<b> PROPERTY (DWORD). </b><br><br>
    'Returns the amount of time (in milliseconds) elapsed since the device powered up. Once the value of this timer reaches &hFFFFFFFF, it rolls over to 0.<br><br>
    'Care should be exercised, because this property is not read-only.
        get = syscall(595) as dword
        set = syscall(596) (value as dword)
    end property

#endif 

#if SYS_VER_SUPPORTS_MSE=1

    property sys.timercountmse
    '<b>R/O PROPERTY.</b><br><br>
    'Returns the amount of time (in milliseconds) elapsed since the device powered up. Once the value of this timer reaches &hFFFFFFFF, it rolls over to 0.<br><br>
    'See also <font color="teal"><b>on_sys_timer </b></font> event.
        get = syscall(875) as dword
    end property

#endif 

#if SYS_VER_SUPPORTS_TRIG=1
'--------------------------------------------------------------------
syscall(808,"91.TDL") sin( angle as float) as float
'<b>PLATFORM SYSCALL. </b><br><br>
'Calculates the sin of angle. Angle is specified in degrees

'--------------------------------------------------------------------
syscall(809,"91.TDL") asin( x as float) as float
'<b>PLATFORM SYSCALL. </b><br><br>
'Calculates the arc sin. Return value angle is in degrees

'--------------------------------------------------------------------
syscall(810,"91.TDL") cos( angle as float) as float
'<b>PLATFORM SYSCALL. </b><br><br>
'Calculates the cos of angle. Angle is specified in degrees

'--------------------------------------------------------------------
syscall(811,"91.TDL") acos( x as float) as float
'<b>PLATFORM SYSCALL. </b><br><br>
'Calculates the arc cos. Return value angle is in degrees

'--------------------------------------------------------------------
syscall(812,"91.TDL") tan( angle as float) as float
'<b>PLATFORM SYSCALL. </b><br><br>
'Calculates the tan of angle. Angle is specified in degrees

'--------------------------------------------------------------------
syscall(813,"91.TDL") atan( x as float) as float
'<b>PLATFORM SYSCALL. </b><br><br>
'Calculates the arc tan. Return value angle is in degrees

'--------------------------------------------------------------------
syscall(828,"91.TDL") sqrt( x as float) as float
'<b>PLATFORM SYSCALL. </b><br><br>
'Calculates the square root.

'--------------------------------------------------------------------
syscall(829,"91.TDL") atan2( y as float, x as float) as float
'<b>PLATFORM SYSCALL. </b><br><br>
'Calculates the square root.

#endif 



#if SYS_VER_SUPPORTS_MONITOR=1

'--------------------------------------------------------------------
property sys.monversion
'<b>R/O PROPERTY (STRING). </b><br><br>
'Returns the version of the Monitor/Loader.
    get = syscall(751) as string
end property

#endif 


#if SYS_VER_SUPPORTS_TIMERCOUNT32=1

'--------------------------------------------------------------------
property sys.timercount32
'<b>R/O PROPERTY (DWORD). </b><br><br>
'Returns the time (in half-second intervals) elapsed since the device powered up. Once the value of this timer reaches &hFFFFFFFF it rolls over to 0.<br><br>
'See also <font color="teal"><b>on_sys_timer </b></font> event.
    get = syscall(594) as dword
end property


#endif 


#if SYS_VER_SUPPORTS_EXTRESETTYPES=1

'--------------------------------------------------------------------
enum pl_sys_ext_reset_type
    PL_SYS_EXT_RESET_TYPE_INTERNAL, '<b>PLATFORM CONSTANT. </b><br><br> The most recent reset was a self-reset.
    PL_SYS_EXT_RESET_TYPE_WATCHDOG, '<b>PLATFORM CONSTANT. </b><br><br> The most recent reset was caused by the watchdog timeout.
    PL_SYS_EXT_RESET_TYPE_POWERUP,  '<b>PLATFORM CONSTANT. </b><br><br> The most recent reset was a power-up/power-down reset.
    PL_SYS_EXT_RESET_TYPE_BROWNOUT, '<b>PLATFORM CONSTANT. </b><br><br> The most recent reset was a brown-out reset.
    PL_SYS_EXT_RESET_TYPE_RSTPIN    '<b>PLATFORM CONSTANT. </b><br><br> The most recent reset was initiated from the RST pin.
end enum

property sys.extresettype
'<b>R/O PROPERTY (BYTE, enum pl_sys_ext_reset_type). </b><br><br>
    get = syscall(597) as pl_sys_ext_reset_type
end property

#endif 


#if SYS_VER_SUPPORTS_WATCHDOG=1


'--------------------------------------------------------------------
property sys.wdenabled
    get = syscall(601) as no_yes
    set = syscall(602) (value as no_yes)
end property
    
'--------------------------------------------------------------------
property sys.wdautoreset
    get = syscall(603) as dis_en
    set = syscall(604) (value as dis_en)
end property

'--------------------------------------------------------------------
property sys.wdperiod
    get = syscall(605) as word
    set = syscall(606) (value as word)
end property

'--------------------------------------------------------------------
syscall(607) sys.wdreset()

#endif 


#if SYS_VER_SUPPORTS_CHANGEDEBUGMODE 1

'--------------------------------------------------------------------
enum pl_sys_debug_mode
	PL_SYS_DBG_SERIAL   'Debugging through the serial port. In this mode, lines PL_IO_NUM_7_RX1 and PL_IO_NUM_8_TX1 cease to work as the device's GPIO lines and become the RX and TX lines of the debug serial port.
                        'The serial port 1 is also disabled (attempting to set ser.num = 1 will have no effect and the property value will remain at 0).
	PL_SYS_DBG_NET      'Debugging through the Wi-Fi port. This debugging method only works when the automatic association with a Wi-Fi network (access point) is enabled (wln.autoconnect = 1- YES),
                        'and the Wi-Fi interface is correctly configured for the target Wi-Fi network (see wln.autoconnectssid, wln.autoconnectpassword).
end enum

'--------------------------------------------------------------------
property sys.debugmode 
'<b>PROPERTY.</b><br><br>
'Indicates whether the device will use the serial or network interface for debugging: 
'<font color="olive"><b>0 - PL_SYS_DBG_SERIAL<b></font> (serial interface), <font color="olive"><b>1 - PL_SYS_DBG_NET<b></font> (Wi-Fi interface).<br><br>
'If this property is set to <font color="olive"><b>0 - PL_SYS_DBG_NET<b></font>, <font color="maroon"><b>wln.autoconnect</b></font> must be enabled for debugging to be possible.<br><br>
'As this is a Device Configuration Block (DCB) property, changing its values requires that the device be restarted for the changes to take effect.
	get = syscall(843) as pl_sys_debug_mode
	set = syscall(844) (value as pl_sys_debug_mode)
end property

#endif 

#if SYS_VER_SUPPORTS_LOWPOWER=1

    #if SYS_VER=1000
        '--------------------------------------------------------------------
        property sys.currentpll
        '<b>R/O PROPERTY (ENUM, BYTE). </b><br><br>
        'Returns current PLL mode of the device:<br><br> <font color="olive"><b>0- OFF </b></font>(PLL is off, the device runs at low speed with
        'reduced power consumption),<br> <font color="olive"><b>1- YES </b></font> (PLL is on, the device runs at maximum speed, x8 faster than
        'low speed). <br><br>
        'After the external reset the device typically boots with PLL on. You can switch PLL off and on programmatically by using the
        '<font color="maroon"><b>sys.newpll</b></font> method and then "self-resetting" the device using the <font color="maroon"><b>sys.reboot
        '</b></font> method.<br><br>
        'Actual change only takes place after you "self-reset" the device using <font color="maroon"><b>sys.reboot </b></font> method or the device
        'self-resets due to some other reason (for instance, there is a self reset after a new BASIC application upload, or when you hit
        '"restart" button in TIDE). <br><br>
        'External resets- power-up and RST pin reset- set the PLL to default state (typically ON). On some devices there is a hardware jumper that 
        'defines the post-external reset state of the PLL. Notice that PLL mode affects other objects- baudrates of serial ports and frequency 
        'generated by the beep object (if present).

            get = syscall(66) as off_on
        end property

        '--------------------------------------------------------------------
        syscall(67) sys.newpll(newpllstate as off_on)
        '<b>METHOD. </b><br><br>
        'Sets new state of the PLL:<br><br><font color="olive"><b>0- OFF </b></font>(PLL will be off, the device will emerge from reset at low speed
        'with reduced power consumption),<br><font color="olive"><b>1- ON </b></font> (PLL will be on, the device will emerge from reset at 
        'maximum speed, x8 faster than low speed).<br><br>
        'Actual change only takes place after you "self-reset" the device using <font color="maroon"><b>sys.reboot</b></font> method or the device 
        'self-resets due to some other reason (for instance, there is a self reset after a new BASIC application upload, or when you hit
        '"restart" button in TIDE). <br><br>
        'External resets- power-up and RST pin reset- set the PLL to default state (typically ON). On some devices there is a hardware jumper that
        'defines the post-external reset state of the PLL. Notice that PLL mode affects other objects- baudrates of serial ports and frequency 
        'generated by the beep object (if present).
 
    #elif SYS_VER=2000 or SYS_VER=3000

        '--------------------------------------------------------------------
        syscall(598) !sys.sleep()

        '--------------------------------------------------------------------
        syscall(599) !sys.stop()

        '--------------------------------------------------------------------
        syscall(600) !sys.standby()

        '--------------------------------------------------------------------
        enum pl_sys_speed_choices
            PL_SYS_SPEED_LOW,       '<b>PLATFORM CONSTANT. </b><br><br> The slowest execution speed.
            PL_SYS_SPEED_MEDIUM,    '<b>PLATFORM CONSTANT. </b><br><br> Medium execution speed.
            PL_SYS_SPEED_FULL       '<b>PLATFORM CONSTANT. </b><br><br> Full execution speed.
        end enum

        '--------------------------------------------------------------------
        property !sys.speed
            get = syscall(608) as pl_sys_speed_choices
            set = syscall(609) (value as pl_sys_speed_choices)
        end property

        '--------------------------------------------------------------------
        property !sys.hsclock
            get = syscall(610) as dis_en
            set = syscall(611) (value as dis_en)
        end property

        '--------------------------------------------------------------------
        property !sys.wakeupperiod
            get = syscall(612) as dword
            set = syscall(613) (value as dword)
        end property

    #elif SYS_VER=2500

        '--------------------------------------------------------------------
        syscall(598) sys.sleep(daycount as word, mincount as word, seconds as byte)
        '<b>METHOD.</b><br><br>
        'Enters a low-power state and reboots the device at the specified date and time.<br><br>
        'This method will block execution of your code until the device is rebooted either manually or by the external sleep hardware (see the Programmable Hardware Manual). 
        'This external sleep hardware is scheduled to reboot the device by specifying the date and time as the number of days (<i>daycount</i>), minutes (<i>mincount</i>), and seconds (<i>seconds</i>) since 1-JAN-2000. 
        'If improperly configured, the device might not "wake" at the desired date and time.<br><br>
        'Note that the device will boot to the compiled Tibbo BASIC/C application binary specified by <font color="maroon"><b>sys.defaultapp</b></font>.

    #endif 

#endif 


#if SYS_VER_SUPPORTS_EXCEPTIONS=1

    '--------------------------------------------------------------------
    syscall(724) sys.getexceptioninfo(byref hfsr as dword, byref cfsr as dword, byref lr as dword, byref pc as dword, byref current_lr as dword)
    '<b>METHOD.</b><br><br>
    'Checks the CPU registers prior to the last crash.<br><br>
    '<b>Input parameters:</b>
    '<ul>
        '<li>hfsr - <i>Hard fault status register</i></li>
        '<li>cfsr - <i>Configurable fault status registers</i></li>
        '<li>lr - <i>Link register</i></li>
        '<li>pc - <i>Program counter</i></li>
        '<li>current_lr - <i>Current link register</i></li>
    '</ul>
    'This method should <b>only</b> be used under the guidance of Tibbo support as part of advanced diagnostic procedures.


    '--------------------------------------------------------------------
    syscall(725) !sys.causeexception()

#endif 


#if SYS_VER_SUPPORTS_MULTIPLE_APPS=1

    '--------------------------------------------------------------------
    enum pl_app_num 
        PL_APP_NUM_0    'APP 0 will be launching after the power-up (reboot). 
        PL_APP_NUM_1    'APP 1 will be launching after the power-up (reboot), unless overridden to APP0 by pressing the MD button. 
    end enum
    
    '--------------------------------------------------------------------
    property sys.defaultapp
    '<b>PROPERTY.</b><br><br>
    'Indicates the default compiled Tibbo BASIC/C application binary the device should load when booting.<br><br>
    'As this is a Device Configuration Block (DCB) property, changing its values requires that the device be restarted for the changes to take effect.
        get = syscall(871) as pl_app_num
        set = syscall(872) (app as pl_app_num)
    end property

    '--------------------------------------------------------------------
    syscall(865) !sys.getsmcs() as string

    '--------------------------------------------------------------------
    syscall(866) !sys.eraseapps(cs0 as byte,cs1 as byte,cs2 as byte,cs3 as byte, both as no_yes) as accepted_rejected

    '--------------------------------------------------------------------
    syscall(867) !sys.restoredefaults(cs0 as byte,cs1 as byte,cs2 as byte,cs3 as byte) as accepted_rejected

    '--------------------------------------------------------------------
    syscall(868) sys.reboottoapp(value as pl_app_num)
    '<b>METHOD.</b><br><br>
    'Reboots the device and loads the specified compiled Tibbo BASIC/C application binary:
    '<font color="olive"><b>0 - PL_APP_NUM_0</b></font> (APP0), <font color="olive"><b>1 - PL_APP_NUM_1</b></font> (APP1).<br><br>
    'Like <font color="maroon"><b>sys.reboot</b></font>, this method will reboot the device, which will behave as after any other reboot: 
    'enter PAUSE mode if your program was compiled for debugging, or start execution if the program was compiled for release. 
    'However, <font color="maroon"><b>sys.reboottoapp</b></font> specifies which compiled Tibbo BASIC/C application binary to load at boot.<br><br>
    'The PLL mode will change after the reboot if you requested the changed through <font color="maroon"><b>sys.newpll</b></font> method.

#endif 

#if SYS_VER_SUPPORTS_SERIALNUM=1

    #if SYS_VER=500 or SYS_VER=510 

    '--------------------------------------------------------------------
    property sys.serialnum
    '<b>R/O PROPERTY (STRING). </b><br><br>
    'Returns the 4-byte string containing the serial number of the device.
    '<br><br>
    'On this platform the serial number is generated automatically and can't be changed.
        get = syscall(255,"74.TDL"+) as string
    end property

    '--------------------------------------------------------------------
    syscall(295,"74.TDL") sys.setserialnum(byref str as string) as ok_ng
    '<b>METHOD. </b><br><br>
    'Not supported on this platfrom, always returns <font color="olive"><b>1- NG </b></font>when invoked.
    #else 

        #if SYS_VER=1000 

        '--------------------------------------------------------------------
        property sys.serialnum
        '<b>R/O PROPERTY (STRING). </b><br><br>
        'Returns the 128-byte string containing the serial number of the device.
        '<br><br>
        'The serial number comes from the security register of the flash IC. Older generation of flash ICs used in our devices did not have the security register.
        'This property will return an empty string if the security register is not present. 
        '<br><br>
        'First 64 bytes of the security register are preprogrammed with a serial number,
        'and remaining 64 bytes are one-time programmable. Use the
        '<font color="maroon"><b>sys.setserialnum </b></font>
        'method to set the data.
            get = syscall(255,"74.TDL"+) as string
        end property

        #elif SYS_VER=2000 or SYS_VER=2500 or SYS_VER=3000

        '--------------------------------------------------------------------
        property sys.serialnum
        '<b>R/O PROPERTY (STRING). </b><br><br>
        'Returns the 12-byte or 128-byte string containing the serial number of the device.
        '<br><br>
        'In the absense of the flash IC, the 12-byte processor ID serves as a serial number. This is a preprogrammed, unalterable ID string.
        'Using <font color="maroon"><b>sys.setserialnum </b></font> won't work. 
        '<br><br>
        'When the flash is installed the 128-byte serial number comes from the security register of the flash IC. 
        'The first 64 bytes of the security register are preprogrammed with a serial number,
        'and remaining 64 bytes are one-time programmable. Use the
        '<font color="maroon"><b>sys.setserialnum </b></font>
        'method to set the data.
            get = syscall(255,"74.TDL"+) as string
        end property

        #endif 

        '--------------------------------------------------------------------
        syscall(295,"74.TDL") sys.setserialnum(byref str as string) as ok_ng
        '<b>METHOD. </b><br><br>
        'Sets the programmable portion (64 bytes) of the device's 128-byte serial number. Returns 
        '<font color="olive"><b>0- OK </b></font>if completed successfully, or 
        '<font color="olive"><b>1- NG </b></font>if this operation failed.
        '<br><br>
        'The serial number is stored in the security register of the flash IC. Older generation of flash ICs used in our devices did not have the security register. This method will return 
        '<font color="olive"><b>1- NG </b></font>if you attempt to set the serial number of the device that does not have the security register.
        '<br><br>
        'For the method to work, the input string must be exactly 64 bytes in length, otherwise 
        '<font color="olive"><b>1- NG </b></font>will be returned. The security register can only be programmed once.  Attempting to program it again will fail (again, with 
        '<font color="olive"><b>1- NG </b></font>code).
        '<br><br>
        'Note that using this method disrupts the operation of the flash memory.
        'The operation uses buffer 1 of the flash IC for temporary data storage, so invoking this method will alter the buffer contents.
        'To prevent potential data errors, invoking the method sets fd.ready= 
        '<font color="olive"><b>0- NO </b></font>automatically.
        '<br><br>
        'The Entire 128-byte serial number can be obtained through the <font color="maroon"><b>sys.serialnum </b></font>R/O property.

    #endif 

#endif 


#if SYS_VER_SUPPORTS_BUFFER_DEBUG=1

'--------------------------------------------------------------------
property !sys.userbuffpages
'<b>R/O PROPERTY (WORD). </b><br><br>
    get = syscall(785) as word
end property

'--------------------------------------------------------------------
syscall(628) !sys.getbuffbasesize(buff_num as byte, byref base as dword, byref size as dword)

#endif 
